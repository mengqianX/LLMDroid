import csv
import glob
import json
import os
import subprocess
import time
from argparse import ArgumentParser, Namespace
from typing import List, Dict
from xml.dom import minidom

from xml.parsers.expat import ExpatError

ALL_APPS = ['ActivityDiary', 'AmazeFileManager', 'and-bible', 'AnkiDroid', 'APhotoManager', 'commons',
            'collect', 'FirefoxLite', 'Frost', 'geohashdroid', 'MaterialFBook', 'nextcloud', 'Omni-Notes',
            'open-event-attendee-android', 'openlauncher', 'osmeditor4android', 'Phonograph', 'Scarlet-Notes',
            'sunflower', 'WordPress', "AntennaPod", "newpipe", 'duckduckgo', 'RedReader', 'owntracks', 'myExpenses', 'bookdash', 'Wikipedia', 'kotatsu', 'aard2']


def get_app_name(testing_result_dir):
    for app_name in ALL_APPS:
        if os.path.basename(testing_result_dir).startswith(app_name):
            return app_name
    print("Warning: cannot find app name for this testing result dir: %s" % testing_result_dir)


def get_apk_name(testing_result_dir: str):
    base_name = os.path.basename(testing_result_dir)
    target_apk_file_name = str(base_name.split(".apk")[0]) + ".apk"
    # target_apk_file_name = str(base_name.split("_")[0]) + ".apk"
    return target_apk_file_name


def get_issue_id(testing_result_dir: str):
    base_name = os.path.basename(testing_result_dir)
    issue_id_str = base_name.split("#")[1].split(".")[0]
    return str(issue_id_str)


def read_coverage_jacoco(jacoco_report_file):
    if not os.path.isfile(jacoco_report_file):
        return False, 0, 0, 0, 0

    try:
        # see the format of coverage report generated by Jacoco in xml
        xmldoc = minidom.parse(jacoco_report_file)
        counters = xmldoc.getElementsByTagName('counter')

        line_coverage = 0
        branch_coverage = 0
        method_coverage = 0
        class_coverage = 0

        for counter in counters:
            type_name = counter.getAttribute('type')
            missed_items = int(counter.getAttribute('missed'))
            covered_items = int(counter.getAttribute('covered'))

            if type_name == 'LINE':
                line_coverage = covered_items * 100.0 / (missed_items + covered_items)

            if type_name == 'BRANCH':
                branch_coverage = covered_items * 100.0 / (missed_items + covered_items)

            if type_name == 'METHOD':
                method_coverage = covered_items * 100.0 / (missed_items + covered_items)

            if type_name == 'CLASS':
                class_coverage = covered_items * 100.0 / (missed_items + covered_items)

        print("-----------")
        print("Line: " + str(line_coverage) + ", Branch: " + str(branch_coverage) + ", Method: " + str(method_coverage)
              + ", Class: " + str(class_coverage))
        print("-----------")
        return True, float("{:.2f}".format(line_coverage)), float("{:.2f}".format(branch_coverage)), \
               float("{:.2f}".format(method_coverage)), float("{:.2f}".format(class_coverage))
    except ExpatError:
        print("*****Parse xml error, catch it!********")
        return False, 0, 0, 0, 0


def get_class_source_files_dirs(app_name, target_apk_file_name):
    class_files = os.path.join("../" + app_name, "class_files.json")
    assert os.path.exists(class_files)

    tmp_file = open(class_files, "r")
    tmp_file_dict = json.load(tmp_file)
    tmp_file.close()

    # Get the class and source files #
    class_source_files_dict = tmp_file_dict[target_apk_file_name]

    class_files_dirs = class_source_files_dict['classfiles']
    source_files_dirs = class_source_files_dict['sourcefiles']

    assert len(class_files_dirs) != 0 and len(source_files_dirs) != 0

    return class_files_dirs, source_files_dirs


def get_class_files_str(app_name, class_files_dirs):
    class_files_dirs_str = ""
    for tmp_dir in class_files_dirs:
        # 使用 os.path.join 并确保路径中的反斜杠正确处理
        class_files_dirs_str += " --classfiles " + os.path.normpath(os.path.join("..", app_name, tmp_dir))
        # class_files_dirs_str += " --classfiles " + os.path.join("../" + app_name, tmp_dir)
    return class_files_dirs_str

def get_valid_ec_file(coverage_data_dir):
    # Get the coverage data files #
    coverage_ec_files = [os.path.join(coverage_data_dir, f) for f in os.listdir(coverage_data_dir) if
                         os.path.isfile(os.path.join(coverage_data_dir, f)) and f.startswith('valid')] 
    return coverage_ec_files  


def merge_before_coverage_ec_files(coverage_data_dir):
    # Get the coverage data files #
    valid_coverage_ec_files = [os.path.join(coverage_data_dir, f) for f in os.listdir(coverage_data_dir) if
                         os.path.isfile(os.path.join(coverage_data_dir, f)) and f.endswith('.ec') and f.startswith('valid')]
    if len(valid_coverage_ec_files)>36:
        return 
    
    coverage_ec_files = [os.path.join(coverage_data_dir, f) for f in os.listdir(coverage_data_dir) if
                         os.path.isfile(os.path.join(coverage_data_dir, f)) and f.endswith('.ec') and not f.startswith('valid')]
    coverage_ec_files_str = ""
    count = 1
    for ec_file in coverage_ec_files:
        coverage_ec_files_str += " " + ec_file
        merged_coverage_ec_file_path = os.path.join(coverage_data_dir, "valid_coverage_all_{}.ec".format(count))
        count += 1

        if not os.path.exists(merged_coverage_ec_file_path):
            # only merge when the "coverage_all.ec" does not exist

            merge_cmd = "java -jar ../tools/jacococli.jar merge " + coverage_ec_files_str + \
                    " --destfile " + merged_coverage_ec_file_path
            print('$ %s' % merge_cmd)

            try:
                p = subprocess.Popen(merge_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                # clear the output
                output = p.communicate()[0].decode('utf-8').strip()
                print(output)
            except os.error as e:
                print(e)
    return



def compute_code_coverage(app_name, tool_name, testing_result_dir, coverage_data_dir):
    target_apk_file_name = get_apk_name(testing_result_dir)

    class_files_dirs, source_files_dirs = get_class_source_files_dirs(app_name, target_apk_file_name)

    class_files_dirs_str = get_class_files_str(app_name, class_files_dirs)

    coverage_ec_files_str = coverage_data_dir

    # handle the case when no coverage data is available
    if len(coverage_ec_files_str) == 0:
        return False, 0, 0, 0, 0

    # Assemble and execute the coverage computation command #
    xml_coverage_report_file_path = os.path.join(testing_result_dir, "coverage_report.xml")
    cmd = "java -jar ../tools/jacococli.jar report " + coverage_ec_files_str + class_files_dirs_str + " --xml " + \
          xml_coverage_report_file_path
    print('$ %s' % cmd)

    import chardet
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    rawdata = p.communicate()[0]
    result = chardet.detect(rawdata)
    encoding = result['encoding']
    output = rawdata.decode(encoding).strip()

    # # clear the output
    # output = p.communicate()[0].decode('utf-8').strip()
    print(output)

    return read_coverage_jacoco(xml_coverage_report_file_path)

def compute_single_code_coverage(target_app_testing_result_dirs):
    merge_before_coverage_ec_files(target_app_testing_result_dirs)
    coverage_ec_files = get_valid_ec_file(target_app_testing_result_dirs)
    app_name = get_app_name(target_app_testing_result_dirs)
    tool_name = "aurora"
    # issue_id = get_issue_id(target_app_testing_result_dirs)
    coverage_data_summary_file_path = os.path.join(target_app_testing_result_dirs,"all_coverage.csv")
    if os.path.isfile(coverage_data_summary_file_path):
        return coverage_data_summary_file_path
    average_coverage_dict: Dict[str, Dict[str, float]] = {}
    for tmp_dir in coverage_ec_files:

        print(tmp_dir)
        
        coverage_data_dir = tmp_dir

        # If is_valid_data is False, it means the no coverage files exists or parsing coverage report failed.
        is_valid_data, line_coverage, branch_coverage, method_coverage, class_coverage = \
            compute_code_coverage(app_name, tool_name, target_app_testing_result_dirs, coverage_data_dir)

        # dump info into csv
        if is_valid_data and line_coverage > 0.0:

            # skip ZERO coverage
            # issue_id_str = get_issue_id(target_app_testing_result_dirs)
            issue_id_str = ''
            if issue_id_str not in average_coverage_dict:
                average_coverage_dict[coverage_data_dir] = {'line': line_coverage,
                                                       'branch': branch_coverage,
                                                       'method': method_coverage,
                                                       'class': class_coverage}
            else:
                tmp_coverage_dict = average_coverage_dict[coverage_data_dir]
                tmp_coverage_dict['line']=line_coverage
                tmp_coverage_dict['branch']=branch_coverage
                tmp_coverage_dict['method']=method_coverage
                tmp_coverage_dict['class']=class_coverage

    for coverage_ec_file in average_coverage_dict:
        print("**** [%s] Compute all coverage data, write to the file ****" % coverage_ec_file)
        tmp_coverage_dict = average_coverage_dict[coverage_ec_file]
        average_line_coverage = tmp_coverage_dict['line']
        average_branch_coverage = tmp_coverage_dict['branch']
        average_method_coverage = tmp_coverage_dict['method']
        average_class_coverage = tmp_coverage_dict['class']

        with open(coverage_data_summary_file_path, "a") as csv_file:
            writer = csv.writer(csv_file)
            writer.writerow(
                [app_name, issue_id_str,coverage_ec_file, average_line_coverage, average_branch_coverage, average_method_coverage,
                 average_class_coverage])
        csv_file.close()
    return coverage_data_summary_file_path

def get_tool_name(testing_result_dir: str):
    base_name = os.path.basename(testing_result_dir)
    base_name = str(base_name.split(".apk.")[1])
    tool_name = str(base_name.split(".result")[0])
    return tool_name

import os
import subprocess
import pandas as pd
import matplotlib.pyplot as plt
from xml.dom import minidom

def get_timestamp(testing_result_dir: str):
    base_name = os.path.basename(testing_result_dir)
    timestamp = str(base_name.split("#")[-1])
    return timestamp



import pandas as pd
import matplotlib.pyplot as plt
import re

# 读取 CSV 文件
# 提取文件名并排序
def extract_file_number(file_path):
    # 使用正则表达式提取文件名中的数字
    match = re.search(r'valid_coverage_all_(\d+)\.ec$', os.path.basename(file_path))
    return int(match.group(1)) if match else float('inf')

if __name__ == "__main__":
    ap = ArgumentParser()
    ap.add_argument('-dir', type=str, dest="root_dir", help="test root dir")
    arg = ap.parse_args()
    root_dir = arg.root_dir # 替换为你的 .ec 文件目录
    coverage_dirs = []
    # run_num = 1
    valid = True
    for subdir in os.listdir(root_dir): 
        subdir = os.path.join(root_dir,subdir)
        if os.path.isdir(subdir):
            print("subdir: ", subdir)
            coverage_dirs.append(str(subdir))
            coverage_data = compute_single_code_coverage(str(subdir))
            if not coverage_data:
                valid = False
    print("coverage dirs: ", coverage_dirs)

    
    # if valid:
    #     plot_coverage(coverage_dirs,run_num)
    # else:
    #     print("No coverage data found.")

